package node_list

import (
	"gitee.com/Anderson/my-algorithm/data_structure"
)

//本题的单链表可能有环， 也可能无环
//请实现一个函数，判断两个链表是否相交， 如果相交，返回相交的第一个节点，
//如果不相交， 返回null

//要求： 如果链表1的长度为N， 链表2 的长度为M， 时间复杂度 O(N+M), 空间复杂度O(1)

//这个问题比较复杂， 可以分解成四个子问题， 每个问题都可以单独出一道算法题
//1. 如何判断一个链表是否有环， 如果有环的话找到第一个入环节点
//2. 如何判断两个无环的链表是否相交
//3. 如何判断一个无环单链表和一个有环单链表是否相交 && 找到相交的位置
//4. 如何判断两个有环单链表是否相交 && 找到相交的位置

/*
问题1.  判断链表是否有环 && 入环节点
快慢指针 快指针每次走两步， 慢指针每次走一步， 如果链表有环，那么快慢指针一定会相遇
否则快指针会先走到头
如果相遇， 快指针回到最初的头节点，慢指针不动，接下来快指针每次也走一步， 慢指针每次还是走一步， 他们第一次相遇的点就是链表的入环节点
证明过程 待补充

问题2. 判断两个无环的链表（假设为M、N）是否相交
第一步， 先遍历两个链表， 找到两个链表的长度 lM， ln（假设lM > ln）
遍历链表， 长的链表先走 lm-ln步， 接下来两个链表的遍历指针来到了同一长度 ，如果遍历是两个指针相等， 说明相交
否则不相交

问题3 如何判断一个无环单链表和一个有环单链表是否相交 && 找到相交的位置
直接说结论： 一个无环单链表和一个有环单链表不可能相交。 证明如下（反证法）
假设： 无环单链表M 与有环单链表N 相交， 相交节点为 X。有以下推论
1. 基于单链表的性质，每个节点只有一个next指针 -> 有环单链表N 的环内节点 的next指针都已占用， 不会有多余的指针指向环外节点
2. M、 N相交的节点X  上游一定有两个指针指向他，而基于结论1，  环内节点不会有多余的指针， 所以X一定在环的上方
3. 如果X在环内的上方，那么X最终一定也会指向环节点 -> X->...->环 为一个有环单链表， 即 M也为有环单链表
4. 结论3 与最初假设不成立， 证伪完毕， 无环单链表和有环单链表不可能相交

问题4. 如何判断两个有环单链表是否相交 && 找到相交的位置
1. 之前我们已经能找到两个有环单链表的入环节点loop、loop2
2. 如果loop1 === loop2， 说明两个链表相交。 且 相交节点在链表的环节点之前，  这就转化成了问题2
3. 如果loop1 ！= loop2， 那么 从loop1 开始遍历单链表M ， 这个指针会在环节点内循环 如果循环了一周后还没遇到loop2， 说明两个链表不相交
4. 如果遇到了loop2， 说明相交， 这个时候返回哪个入环节点(loop1,loop2) 都对
*/

func GetLoopNode(head1, head2 *data_structure.Node) *data_structure.Node {
	return nil
}
